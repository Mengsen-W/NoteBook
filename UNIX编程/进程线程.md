# 进程和线程总结
---
## 进程
1. ### 进程标识符 pid
   1. 类型 pid_t
   2. 命令ps查看进程
   3. 顺次向下使用，类似电梯算法
   4. getpid()/getppid()

2. ### 进程的产生
   1. fork()
   2. 不同，返回值，pid，ppid，未决信号，文件锁，闹钟号时间清零
   3. 读时共享写时复制
   4. 父子进程的顺序不定
   5. 在fork前刷新流，否则遇到全缓冲的IO可能导致两个缓冲区里面内容错误

3. ### 进程的消亡及释放资源
   1. wait()
   2. 注意waitpid()的非阻塞状态

4. ### exec函数族
   1. execl/execlp/execle/execv/execvp
   2. 注意涮新缓冲区，防止新进程过来，强刷掉全缓冲的内容

5. ### 用户权限组权限
   1. u+s/g+s 执行时用创建文件人/组的权限

6. ### system()
   1. 相当于调用shell，也就是 fork+exec+wait

7. ### 守护进程()
   1. 独占会话和进程组不在前台的父进程是init的进程
   2. 单实例的守护进程，采用锁文件 /var/run/name.pid

---
## 并发
1. ### 信号
   1. 概念
      1. 信号是软件中断
      2. 信号的响应依赖于中断
   2. signal()
      1. void (*signal(int signum, void(*func)(int)))(int)
      2. 信号会打断阻塞的系统调用
   3. 信号的不可靠
      1. 一个信号在执行的时候，另一个相同信号不执行
   4. 可重入函数
      1. 能过避免信号的不可靠
      2. 所有的系统调用都是可重入的，一部分库函数也是可重入的，类如memcpy
   5. 信号的响应过程
      1. 内核为每个进程维护了两个位图 mask/pending，信号修改全在内核中
      2. mask初始全为1，pending位图初始全为0
      3. 在进程中断后，保存现场进入内核就绪队列
      4. 出队列时，将mask&pending，没收到信号时，结果全为0，这时继续执行
      5. 在得到信号后，打断系统调用，进入内核，pending中的某一位变为1，两个位图变为[1, 1]，下一次时间片轮转被打断进入内核态后
      6. 按位与变成1后才会执行调用操作
      7. 出内核态响应信号，执行的过程中[0, 0],由mask找到注册函数
      8. 信号注册函数执行完毕后陷入内核
      9. 陷入内核，重置mask，更改mask位为1[1, 0]，返回被打断现场的非阻塞状态
      10. 信号从收到到响应有一个不可避免的时延
      11. 标准信号的响应没有完全的顺序
      12. 所以SIG_IGN的作用时把mask位图的对应位置为0
      13. 所以多相同信号时位图置1只能一次
      14. pending 反应信号是否到来，mask反应是否执行
   6. 常用函数
      1. kill()
      2. raise()：给自己发送一个信号
      3. alarm(): 以最后一个为准，多个产生错误尽量不写
      4. pause(): 自我陷入而是先入等待alarm
      5. setitimer():延时累计的计时器
      6. abort()：给当前进程发送 abort 信号，产生一个core dump
      7. system()：在信号中由陷阱
      8. sleep(): 在有的环境中是用alarm和pause封装的，可能与自己写的alarm冲突
   7. 信号集
      1. sigset_t
      2. sigemptyset()
      3. sigfillset()
      4. sigaddset()
      5. sigdelset()
      6. sigismember()
   8. 信号屏蔽字/pending集处理
      1. sigpromask()
      2. sigpending() 这个函数透露出一种人类迷惑行为
   9.  扩展
      1. sigsuspend() 原子操作解除mask+pause
      2. sigaction()
         1. 在响应当前信号是可以把别的信号阻塞住，防止重复调用中重复释放资源，即使防止可重入现象
         2. 可是实现收到信号的所有属性信息
   10. 实时信号
       1. 排队+顺序
       2. 先响应标准信号再响应实时信号
       3. 是否是实时信号和函数没关系和信号种类有关
       4. 实时信号不丢失
2. ### 线程