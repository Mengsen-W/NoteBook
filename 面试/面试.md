<!--
 * @Date: 2021-03-09 22:26:52
 * @Author: mengsen wang
 * @LastEditors: mengsen
 * @LastEditTime: 2021-03-11 16:33:05
 * @FilePath: \NoteBook\面试\面试.md
-->

# 后台开发面试

## 语言

* static 关键字的用法
  1. 函数内的 static 局部静态变量：变量在程序初始话时被分配，直到程序退出前才被释放，在定义的作用域可见。也就是 static 是按照程序的生命周期来分配释放变量的，而不是函数本身的生命周期。
  2. cpp文件内部的 static 静态全局变量：只在cpp内部有效。在不同cpp文件中定义同名变量，不必担心命名冲突。在文件内部保持内容的持久。生命周期是全部程序
  3. 在头文件内定义 static 在每一个包含头文件的cpp文件内是独立的可能引起歧义，生命周期问整个函数。不推荐使用。不如定义在cpp内部。
  4. static修饰函数为静态函数，仅在当前文件内部有效，对其他文件隐藏。
  5. 类的static数据成员：必须在类的外部初始化。因为静态成员属于整个类，实际上并不是类本身的成员，在全局区，在类的内部定义会使类的每一个对象都有该对象，这与整个类维护一个静态成员的初衷不符。
  6. 类的 static 函数：因其不需要this指针，不能访问类的私有成员，故只能访问类的 static 成员，或其他静态量，不需要类的实例。也可以理解为静态的static函数是整个类共有，而不是对于特定对象的函数，如果由某一实例调用时实例的this指针是指不到这个函数的，但却要指向实例中的对象，可能产生冲突。可以继承和覆盖，无法使虚函数。非静态成员函数可以任意地访问静态函数和静态数据成员。静态成员函数不能访问非静态成员函数和非静态数据成员。
  7. 在单例模式中使用static，保证一个类仅有一个实例，并提供访问他的全局访问点。

* 内存分区
  1. 栈（stack）：指那些由编译器在需要的时候分配，不需要时⾃动清除的变量所在的存储区，效率高，分配的内存空间有限，形参和局部变量分配在栈区，栈是向地地址生长的数据结构，是一块连续的内存
  2. 堆（heap）：由程序员控制内存的分配和释放的存储区，是向高地址生长的数据结构，是不连续的存储空间，堆的分配(malloc)和释放(free)有程序员控制，容易造成二次删除和内存泄漏
  3. 静态存储区（static）：存放全局变量和静态变量的存储区，初始化的变量放在初始化区data，未初始化的变量放在未初始化区BSS。在程序结束后释放这块空间
  4. 常量存储区（const）：存放常量字符串的存储区，只能读不能写，const修饰的全局/静态变量存储在常量区（取决于编译器），const修饰的局部变量在栈区
  5. 程序代码区：存放源程序二进制代码

* 全局变量与局部变量与const 修饰
  1. 局部变量存在于函数栈中，全局变量位于静态存储区，经过const修饰的变量放在栈区，全局变量放在常量区。初始化的全局变量放在data区未初始化的放在BSS区
  2. 单一`static`类内定义，类外初始化
  3. `const static`类内定义或者构造定义

* 编译过程
  1. 预处理--宏和头文件的展开 `-E`选项
  2. 编译优化--词法语法分析，编译成汇编代码 `-S`选项
  3. 汇编--转换成机器指令 `as` 工具
  4. 链接--链接必要的库 `ld`工具

* 继承和组合
  1. 继承对应于*is-a*关系，组合对应*have-a*关系

* c++ 菱形继承
  1. 可能会拷贝两份顶层虚类
  2. 使用`virtual`继承方式可以避免
  3. 几个虚继承就会产生几个虚指针
  4. 利用虚指针查许虚函数表构造多态

* c++ 智能指针
  1. `unique_ptr`所有权单一
  2. `shared_ptr`共享对象，对象本身线程安全，但是封装的指针线程不安全
  3. `weak_ptr`弱引用解决循环引用和析构自由问题
  4. `auto_ptr`不用了

* 如果父类中只有方法，子类中有一个int变量，sizeof() 是多大
  1. 如果没有虚继承，没有`static`那么基类为1，子类为4
  2. 如果有`static`那么父类子类都是1

* 指针一定是4个字节吗
  1. 32位4字节，64位8字节，指针的大小与内存位数一致

* #define和inline函数的区别是什么
  1. 宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，返回值也不能被强制转换为可转换的合适的类型，在展开代码中都是用形参替换实参很容易产生二意性，宏不能访问对象私有成员，不能在运行时调试
  2. 内联函数在运行时可调试，编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），内联函数可以访问类的成员变量；

* 派生类的构造函数和析构函数的执行顺序
  1. 先构造基类再构造子类，先析构子类在析构基类
  2. 如果基类有虚函数，那么若析构函数不是虚函数泽不能正常析构基类

* 动态库静态库
  1. 使用 `ar -rc` 生成静态库
  2. 使用 `-fPIC -shared` 生成动态库，使用`readelf`查看动态库包括哪些其它库
  3. 静态库被使用目标代码最终和可执行文件在一起（它只会有自己用到的），而动态库与它相反，它的目标代码在运行时或者加载时链接
  4. 静态链接的可执行文件要比动态链接的可执行文件要大得多，因为它将需要用到的代码从二进制文件中“拷贝”了一份，而动态库仅仅是复制了一些重定位和符号表信息
  5. 如果有多个可执行文件，那么静态库中的同一个函数的代码就会被复制多份，而动态库只有一份，因此使用静态库占用的磁盘空间相对比动态库要大
  6. 如果静态库中某个函数的实现变了，那么可执行文件必须重新编译，而对于动态链接生成的可执行文件，只需要更新动态库本身即可，不需要重新编译可执行文件。正因如此，使用动态库的程序方便升级和部署
  7. 静态链接的可执行文件不需要依赖其他的内容即可运行，而动态链接的可执行文件必须依赖动态库的存在。所以如果你在安装一些软件的时候，提示某个动态库不存在的时候也就不奇怪了
  8. 动态库原则是读共享写复制

* 调试相关
  1. `ulimit -c`查看文件大小限制，`ulimit -cn`设置大小
  2. `gdb 二进制可执行文件 core文件`
  3. `gdb attach`用来追踪运行中的程序

## 算法

## 网路

## 系统

## 数据库

## Linux
