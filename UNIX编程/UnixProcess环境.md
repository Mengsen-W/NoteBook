# Unix 线程
---
---
## 进程环境
1. 进程进入
   1. 从main函数入口进入
2. 进程终止
   1. 正常终止
      1. 从main返回；
      2. 调用exit；
      3. 调用_exit或_Exit；
      4. 最后一个线程从其启动例程返回；
      5. 从最后一个线程调用pthread_exit；
   2. 异常中止
      1. 调用abort；
      2. 接到一个信号
      3. 最后一个线程对取消请求做出响应
   3. 终止函数
      1. void exit(int status); 完成清理后终止
      2. void _Exit(int status);直接进入内核终止
      3. void _exit(int status);直接进入内核终止，不进行冲洗操作
      4. int atexit(void (*func)(void));终止处理函数
3. 环境表
   1. int main(int argc, char *argv[], char *envp[]);其中第3个参数就是环境表地址,即指向环境配置
4. 内存模型由高到低
   1. 命令行参数和环境变量
   2. 栈由高向低增长--自动变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其返回地址以及调用者的环境信息（如某些机器寄存器的值）都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间。
   3. 未定义共享区--动态链接
   4. 堆由低向高增长--动态储存
   5. 全局未初始化区
   6. 全局初始化区
   7. 保留地址4k
5. 储存空间分配
   1. malloc calloc realloc free
   2. 返回的指针是适当对齐的
   3. 大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息——分配块的长度、指向下一个分配块的指针等
6. 环境变量 env
   1. char *getenv(const char *name); 返回 name=value 中的 value指针
   2. int putenv(char *str);取形式为 name=value 的字符串放入环境变量
   3. int setenv(const char *name, const char *value, int rewrite);setenv将name设置为value。如果在环境中name已经存在，那么若rewrite非0，则首先删除其现有的定义；若rewrite为0，则不删除其现有定义（name不设置为新的value，而且也不出错）
   4. int unsetenv(const char *name);unsetenv删除name的定义。即使不存在这种定义也不算出错。
   5. setenv必须分配存储空间，以便依据其参数创建name=value字符串。putenv可以自由地将传递给它的参数字符串直接放到环境中。确实，许多实现就是这么做的，因此，将存放在栈中的字符串作为参数传递给putenv就会发生错误，其原因是，从当前函数返回时，其栈帧占用的存储区可能将被重用。
7. 跨函数跳转
   1. goto语句是不能跨越函数的，而执行这种类型跳转功能的是函数setjmp和longjmp。这两个函数对于处理发生在很深层嵌套函数调用中的出错情况是非常有用的
8. getrlimi setrlimit函数查询和更改进程资源限制
   1. 每个进程都有一组资源限制 ulimit -a 查看
   2. 任何一个进程都可将一个软限制值更改为小于或等于其硬限制值。
   3. 任何一个进程都可降低其硬限制值，但它必须大于或等于其软限制值。这种降低，对普通用户而言是不可逆的。
   4. 只有超级用户进程可以提高硬限制值
   5. 常量RLIM_INFINITY指定了一个无限量的限制
---

## 进程控制
1. 进程标识
   1. 进程ID唯一但是可复用，采用复用延迟算法
   2. ID为0的进程通常是调度进程，常常被称为交换进程（swapper），该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。也是唯一一个没有通过fork或者kernel_thread产生的进程。完成加载系统后，演变为进程调度、交换。
   3. 进程ID 1通常是init进程，在自举过程结束时由内核调用，init通常读取与系统有关的初始化文件并将系统引导到一个状态（如多用户）。init 进程决不会终止。它是一个普通的用户进程（与交换进程不同，它不是内核中的系统进程），但是它以超级用户特权运行。在系统启动完成完成后，init将变为守护进程监视系统其他进程。
2. fork函数
   1. 由fork创建的新进程被称为子进程（child process）。fork函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程 ID。
   2. 子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间部分。父进程和子进程共享正文段。总体原则为读时共享写时复制
   3. 在fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。如果要求父进程和子进程之间相互同步，则要求某种形式的进程间通信
   4. 父进程和子进程共享文件描述符表和mmap映射区
   5. 子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0
   6. 子进程不继承父进程设置的文件锁
   7. 子进程的未处理闹钟被清除
   8. 子进程的未处理信号集设置为空集
   9.  两中常见用法
      1.  一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是常见的—父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求。
      2.  一个进程要执行一个不同的程序。这对 shell 是常见的情况。在这种情况下，子进程从fork返回后立即调用exec
3. vfork函数
   1. vfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序
   2. vfork与fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec（或exit），于是也就不会引用该地址空间，不过在子进程调用exec或exit之前，它在父进程的空间中运行。
   3. vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行，当子进程调用这两个函数中的任意一个时，父进程会恢复运行。（如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。）
4. exit函数
5. wait和waitpid函数
6. waitid函数
7. wait3和wait4函数
8. 竞争条件
9.  exec函数
10. 更改用户id和用户组id
11. 解释器文件
12. 函数system
13. 进程会计
14. 用户标识
15. 进程调度
16. 进程时间
## 进程关系
## 信号