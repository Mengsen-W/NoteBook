# Unix 线程
---
---
## 进程环境
1. 进程进入
   1. 从main函数入口进入
2. 进程终止
   1. 正常终止
      1. 从main返回；
      2. 调用exit；
      3. 调用_exit或_Exit；
      4. 最后一个线程从其启动例程返回；
      5. 从最后一个线程调用pthread_exit；
   2. 异常中止
      1. 调用abort；
      2. 接到一个信号
      3. 最后一个线程对取消请求做出响应
   3. 终止函数
      1. void exit(int status); 完成清理后终止
      2. void _Exit(int status);直接进入内核终止
      3. void _exit(int status);直接进入内核终止，不进行冲洗操作
      4. int atexit(void (*func)(void));终止处理函数
3. 环境表
   1. int main(int argc, char *argv[], char *envp[]);其中第3个参数就是环境表地址,即指向环境配置
4. 内存模型由高到低
   1. 命令行参数和环境变量
   2. 栈由高向低增长--自动变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其返回地址以及调用者的环境信息（如某些机器寄存器的值）都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间。
   3. 未定义共享区--动态链接
   4. 堆由低向高增长--动态储存
   5. 全局未初始化区
   6. 全局初始化区
   7. 保留地址4k
5. 储存空间分配
   1. malloc calloc realloc free
   2. 返回的指针是适当对齐的
   3. 大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息——分配块的长度、指向下一个分配块的指针等
6. 环境变量 env
   1. char *getenv(const char *name); 返回 name=value 中的 value指针
   2. int putenv(char *str);取形式为 name=value 的字符串放入环境变量
   3. int setenv(const char *name, const char *value, int rewrite);setenv将name设置为value。如果在环境中name已经存在，那么若rewrite非0，则首先删除其现有的定义；若rewrite为0，则不删除其现有定义（name不设置为新的value，而且也不出错）
   4. int unsetenv(const char *name);unsetenv删除name的定义。即使不存在这种定义也不算出错。
   5. setenv必须分配存储空间，以便依据其参数创建name=value字符串。putenv可以自由地将传递给它的参数字符串直接放到环境中。确实，许多实现就是这么做的，因此，将存放在栈中的字符串作为参数传递给putenv就会发生错误，其原因是，从当前函数返回时，其栈帧占用的存储区可能将被重用。
7. 跨函数跳转
   1. goto语句是不能跨越函数的，而执行这种类型跳转功能的是函数setjmp和longjmp。这两个函数对于处理发生在很深层嵌套函数调用中的出错情况是非常有用的
8. getrlimi setrlimit函数查询和更改进程资源限制
   1. 每个进程都有一组资源限制 ulimit -a 查看
   2. 任何一个进程都可将一个软限制值更改为小于或等于其硬限制值。
   3. 任何一个进程都可降低其硬限制值，但它必须大于或等于其软限制值。这种降低，对普通用户而言是不可逆的。
   4. 只有超级用户进程可以提高硬限制值
   5. 常量RLIM_INFINITY指定了一个无限量的限制
---

## 进程控制
1. 进程标识
   1. 进程ID唯一但是可复用，采用复用延迟算法
   2. ID为0的进程通常是调度进程，常常被称为交换进程（swapper），该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。也是唯一一个没有通过fork或者kernel_thread产生的进程。完成加载系统后，演变为进程调度、交换。
   3. 进程ID 1通常是init进程，在自举过程结束时由内核调用，init通常读取与系统有关的初始化文件并将系统引导到一个状态（如多用户）。init 进程决不会终止。它是一个普通的用户进程（与交换进程不同，它不是内核中的系统进程），但是它以超级用户特权运行。在系统启动完成完成后，init将变为守护进程监视系统其他进程。
2. fork函数
   1. 由fork创建的新进程被称为子进程（child process）。fork函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程 ID。
   2. 子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间部分。父进程和子进程共享正文段。总体原则为读时共享写时复制
   3. 在fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。如果要求父进程和子进程之间相互同步，则要求某种形式的进程间通信
   4. 父进程和子进程共享文件描述符表和mmap映射区
   5. 子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0
   6. 子进程不继承父进程设置的文件锁
   7. 子进程的未处理闹钟被清除
   8. 子进程的未处理信号集设置为空集
   9.  两中常见用法
      1.  一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是常见的—父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求。
      2.  一个进程要执行一个不同的程序。这对 shell 是常见的情况。在这种情况下，子进程从fork返回后立即调用exec
3. vfork函数
   1. vfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序
   2. vfork与fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec（或exit），于是也就不会引用该地址空间，不过在子进程调用exec或exit之前，它在父进程的空间中运行。
   3. vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行，当子进程调用这两个函数中的任意一个时，父进程会恢复运行。（如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。）
4. exit函数
   1. 我们都希望终止进程能够通知其父进程它是如何终止的。对于 3个终止函数（exit、_exit和_Exit），实现这一点的方法是，将其退出状态（exit status）作为参数传送给函数。在异常终止情况，内核（不是进程本身）产生一个指示其异常终止原因的终止状态（termination status）。在任意一种情况下，该终止进程的父进程都能用wait或waitpid函数取得其终止状态。
   2. 先于子进程终止的父进程产生孤儿进程，但是被init收养的进程不会产生僵死；子进程终止但是父进程未释放期资源产生僵尸进程
5. wait和waitpid函数
   1. 如果其所有子进程都还在运行，则阻塞。
   2. 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。
   3. 如果它没有任何子进程，则立即出错返回
   4. 则终止进程的终止状态就存放在形参列表内所指向的单元内。如果不关心终止状态，则可将该参数指定为空指针。
6. waitid函数
   1. 类似waitpid但是有更多灵活性
7. wait3和wait4函数
   1. 更多选项的waitpid
8. 竞争条件
   1. 当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了竞争条件
9.  exec函数
    1.  子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段。
10. 更改用户id和用户组id
    1. 只有超级用户进程可以更改实际用户ID
    2. 仅当对程序文件设置了设置用户ID位时，exec函数才设置有效用户ID
    3. 保存的设置用户ID是由exec复制有效用户ID而得到的
11. 解释器文件
    1. 对这种文件的识别是由内核作为 exec系统调用处理的一部分来完成的。内核使调用 exec函数的进程实际执行的并不是该解释器文件，而是在该解释器文件第一行中pathname所指定的文件。一定要将解释器文件（文本文件，它以#!开头）和解释器（由该解释器文件第一行中的pathname指定）区分开来。
12. 函数system
    1.  system()会调用fork()产生子进程，由子进程来调用/bin/sh-c string来执行参数string字符串所代表的命令。此命令执行完后随即返回原调用的进程。在调用system()期间SIGCHLD 信号会被暂时搁置，SIGINT和SIGQUIT信号则会被忽略。
    2. fork失败或者waitpid返回除EINTR之外的出错，则system返回−1，并且设置errno以指示错误类型。
    3. 如果 exec失败（表示不能执行 shell），则其返回值如同 shell执行了 exit(127)一样。
    4. 否则所有3个函数（fork、exec和waitpid）都成功，那么system的返回值是shell的终止状态，其格式已在waitpid中说明。
    5. 是一种安全的进程控制函数
13. 进程会计
    1. 启用该选项后，每当进程结束时内核就写一个会计记录。典型的会计记录包含总量较小的二进制数据，一般包括命令名、所使用的CPU时间总量、用户ID和组ID、启动时间等。
    2. 我们不能获取永远不终止的进程的会计记录类似init进程
    3. 在会计文件中记录的顺序对应于进程终止的顺序，而不是它们启动的顺序。为了确定启动顺序，需要读全部会计文件，并按启动日历时间进行排序
14. 用户标识
    1.  如果调用此函数的进程没有连接到用户登录时所用的终端，则函数会失败。通常称这些进程为守护进程（daemon）
15. 进程调度
    1. 调度策略和调度优先级是由内核确定的。进程可以通过调整nice值选择以更低优先级运行，nice值越小，优先级越高。
16. 进程时间
    1. 传入的结构没有包含墙上时钟时间。times函数返回墙上时钟时间作为其函数值。此值是相对于过去的某一时刻度量的，所以不能用其绝对值而必须使用其相对值
---

## 进程关系
1. 终端登录
   1. init fork() -> ssh()/getty exec() -> login(处理环境)-> 执行其他进程
   2. 主shell fork() -> 子shell(exec) -> (一些命令) -> 主shell等待子shell执行结束
2. 进程组
   1. 进程组是一个或多个进程的集合
   2. 每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID。
   3. 只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关
   4. 进程组组长可以创建一个进程组、创建该组中的进程，终止该组进程
   5. 一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了exec后，它就不再能更改该子进程的进程组ID，因为调用会更新逻辑地址空间，这里可能产生了一个重分配内存的过程，导致父进程没有子进程的部分指针了，也就是当子进程调用了exec之后，就完全与父进程分道扬镳了，父进程就不能再改变子进程的进程组ID了
3. 会话
   1. 会话（session）是一个或多个进程组的集合
   2. 通常是由shell的管道将几个进程编成一组的
   3. 如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体会发生以下3件事。
      1. 该进程变成新会话的会话首进程（session leader，会话首进程是创建该会话的进程）。此时，该进程是新会话中的唯一进程。
      2. 该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。
      3. 该进程没有控制终端（下一节讨论控制终端）。如果在调用 setsid 之前该进程有一个控制终端，那么这种联系也被切断。
   4. 如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID则是新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长
   5. 会话首进程总是一个进程组的组长进程，所以两者是等价的
4. 控制终端
5. 函数
6. 作业控制
7. shell执行程序
8. 孤儿进程组
## 信号