<!--
 * @Date: 2021-03-09 22:26:52
 * @Author: mengsen wang
 * @LastEditors: Mengsen Wang
 * @LastEditTime: 2021-03-15 11:24:36
 * @FilePath: \NoteBook\面试\面试.md
-->

# 后台开发面试

## 语言

* static 关键字的用法
  01. 函数内的 static 局部静态变量：变量在程序初始话时被分配，直到程序退出前才被释放，在定义的作用域可见。也就是 static 是按照程序的生命周期来分配释放变量的，而不是函数本身的生命周期。
  02. cpp文件内部的 static 静态全局变量：只在cpp内部有效。在不同cpp文件中定义同名变量，不必担心命名冲突。在文件内部保持内容的持久。生命周期是全部程序
  03. 在头文件内定义 static 在每一个包含头文件的cpp文件内是独立的可能引起歧义，生命周期问整个函数。不推荐使用。不如定义在cpp内部。
  04. static修饰函数为静态函数，仅在当前文件内部有效，对其他文件隐藏。
  05. 类的static数据成员：必须在类的外部初始化。因为静态成员属于整个类，实际上并不是类本身的成员，在全局区，在类的内部定义会使类的每一个对象都有该对象，这与整个类维护一个静态成员的初衷不符。
  06. 类的 static 函数：因其不需要this指针，不能访问类的私有成员，故只能访问类的 static 成员，或其他静态量，不需要类的实例。也可以理解为静态的static函数是整个类共有，而不是对于特定对象的函数，如果由某一实例调用时实例的this指针是指不到这个函数的，但却要指向实例中的对象，可能产生冲突。可以继承和覆盖，无法使虚函数。非静态成员函数可以任意地访问静态函数和静态数据成员。静态成员函数不能访问非静态成员函数和非静态数据成员。
  07. 在单例模式中使用static，保证一个类仅有一个实例，并提供访问他的全局访问点。

* 内存分区
  01. 栈（stack）：指那些由编译器在需要的时候分配，不需要时⾃动清除的变量所在的存储区，效率高，分配的内存空间有限，形参和局部变量分配在栈区，栈是向地地址生长的数据结构，是一块连续的内存
  2. 堆（heap）：由程序员控制内存的分配和释放的存储区，是向高地址生长的数据结构，是不连续的存储空间，堆的分配(malloc)和释放(free)有程序员控制，容易造成二次删除和内存泄漏
  03. 静态存储区（static）：存放全局变量和静态变量的存储区，初始化的变量放在初始化区data，未初始化的变量放在未初始化区BSS。在程序结束后释放这块空间
  04. 常量存储区（const）：存放常量字符串的存储区，只能读不能写，const修饰的全局/静态变量存储在常量区（取决于编译器），const修饰的局部变量在栈区
  05. 程序代码区：存放源程序二进制代码

* 全局变量与局部变量与const 修饰
  01. 局部变量存在于函数栈中，全局变量位于静态存储区，经过const修饰的变量放在栈区，全局变量放在常量区。初始化的全局变量放在data区未初始化的放在BSS区
  02. 单一`static`类内定义，类外初始化
  03. `const static`类内定义或者构造定义

* 编译过程
  01. 预处理--宏和头文件的展开 `-E`选项
  02. 编译优化--词法语法分析，编译成汇编代码 `-S`选项
  03. 汇编--转换成机器指令 `as` 工具
  04. 链接--链接必要的库 `ld`工具

* 继承和组合
  1. 继承对应于*is-a*关系，组合对应*have-a*关系

* c++ 菱形继承
  01. 可能会拷贝两份顶层虚类
  02. 使用`virtual`继承方式可以避免
  03. 几个虚继承就会产生几个虚指针
  04. 利用虚指针查许虚函数表构造多态

* c++ 智能指针
  01. `unique_ptr`所有权单一
  02. `shared_ptr`共享对象，对象本身线程安全，但是封装的指针线程不安全
  03. `weak_ptr`弱引用解决循环引用和析构自由问题
  04. `auto_ptr`不用了

* 如果父类中只有方法，子类中有一个int变量，sizeof() 是多大
  01. 如果没有虚继承，没有`static`那么基类为1，子类为4
  02. 如果有`static`那么父类子类都是1

* 指针一定是4个字节吗
  01. 32位4字节，64位8字节，指针的大小与内存位数一致

* #define和inline函数的区别是什么
  01. 宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，返回值也不能被强制转换为可转换的合适的类型，在展开代码中都是用形参替换实参很容易产生二意性，宏不能访问对象私有成员，不能在运行时调试
  02. 内联函数在运行时可调试，编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），内联函数可以访问类的成员变量；

* 派生类的构造函数和析构函数的执行顺序
  01. 先构造基类再构造子类，先析构子类在析构基类
  02. 如果基类有虚函数，那么若析构函数不是虚函数泽不能正常析构基类

* 动态库静态库
  01. 使用 `ar -rc` 生成静态库
  02. 使用 `-fPIC -shared` 生成动态库，使用`readelf`查看动态库包括哪些其它库
  03. 静态库被使用目标代码最终和可执行文件在一起（它只会有自己用到的），而动态库与它相反，它的目标代码在运行时或者加载时链接
  04. 静态链接的可执行文件要比动态链接的可执行文件要大得多，因为它将需要用到的代码从二进制文件中“拷贝”了一份，而动态库仅仅是复制了一些重定位和符号表信息
  05. 如果有多个可执行文件，那么静态库中的同一个函数的代码就会被复制多份，而动态库只有一份，因此使用静态库占用的磁盘空间相对比动态库要大
  06. 如果静态库中某个函数的实现变了，那么可执行文件必须重新编译，而对于动态链接生成的可执行文件，只需要更新动态库本身即可，不需要重新编译可执行文件。正因如此，使用动态库的程序方便升级和部署
  07. 静态链接的可执行文件不需要依赖其他的内容即可运行，而动态链接的可执行文件必须依赖动态库的存在。所以如果你在安装一些软件的时候，提示某个动态库不存在的时候也就不奇怪了
  08. 动态库原则是读共享写复制

* 调试相关
  01. `ulimit -c`查看文件大小限制，`ulimit -cn`设置大小
  02. `gdb 二进制可执行文件 core文件`
  03. `gdb attach`用来追踪运行中的程序

## 算法

00. 各种排序算法
    01. 快排序
    02. 堆排序
    03. topK
01. 链表是否有环，找到环入口
02. 字符串相减
03. 回文链表
04. LRU
05. 两数和
06. 排序链表
07. 爬楼梯（斐波那契数列）
08. 1到100加和多种算法
09. memcpy函数实现
10. 跳跃游戏
11. 数组中的重复数字
12. 二叉搜索树的第k大节点
13. 合并有序链表
14. 写一个栈
15. 全排列II
16. 最长回文子串
17. 寻找两个正序数组的中位数
18. rand7()到rand10()
19. 接雨水
20. 有效括号
21. 奇偶链表
22. 反转链表II
23. 相同的树
24. 最长公共子串
25. 最大连续子数组和
26. 进制转换
27. 编辑距离
28. 在字符串S1中删除S2中的字符
29. 链表相交
30. 2的幂

## 网路

* `GET`和`POST`区别
  01. GET在浏览器回退是无害的，而POST会再次提交请求
  02. GET产生的URL地址可以被网址收藏BOOKMARK，而POST不可以
  03. GET请求只能进行url编码，而post支持多种编码形式
  04. get请求参数会被完整保留在浏览器历史记录里，而post中的参数不会被保留
  05. get请求在url中传递的参数是有长度限制的不超过4k，而post没有
  06. 对参数的数据类型，get只接受ASCII类型，而post没有限制
  07. get比post更不安全，因为参数直接暴露在url上，所以不能用传递敏感信息
  08. get参数通过url传递，post放在request body报文体中
  09. get产生一个tcp数据包，post产生两个tcp数据包

* `cookie`和`session`区别
  01. cookie 和session的区别是：cookie数据保存在客户端，session数据保存在服务器端。
  02. 两个都可以用来存私密的东西，同样也都有有效期的说法,区别在于session是放在服务器上的，过期与否取决于服务期的设定，cookie是存在客户端的，过去与否可以在cookie生成的时候设置进去。
  03. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session ；
  04. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE ；
  05. 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K；
  06. 所以将登陆信息等重要信息存放为SESSION; 其他信息如果需要保留，可以放在COOKIE中。
  07. cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。
  08. cookie 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在某个WEB站点会话间持久的保持数据。

* `HTTP1.0` `HTTP1.1` `HTTP2.0`的区别
  01. HTTP1.0默认短连接，可以长连接，但是需要设置header connection：keep_Alive，HTTP1.1默认长连接
  02. HTTP2.0支持二进制传输数据，更加安全快捷，而 HTTP1.0， HTTP1.1支持文本
  03. HTTP2.0实现多路复用，更加快捷
  04. HTTP2.0压缩header
  05. HTTP2.0支持服务“主动”给客户端缓存发送数据

## 系统

## 数据库

## Linux
