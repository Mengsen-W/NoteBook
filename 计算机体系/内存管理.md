<!--
 * @Date: 2021-03-11 15:22:20
 * @Author: mengsen
 * @LastEditors: mengsen
 * @LastEditTime: 2021-03-11 15:38:15
 * @FilePath: \NoteBook\计算机体系\内存管理.md
-->

# 内存管理

01. 预备知识

   1. 从写程序到程序运行

      01. 编辑源代码文件
      02. 编译

         - 由源代码文件生成目标模块，高级语言翻译成机械语言

      03. 链接

         - 有目标模块生成装入模块，链接后形成完整的逻辑地址

      04. 装入

         - 将装入模块装入内存，装入后形成物理地址

   2. 三种链接方式

      01. 静态链接

         - 装入前链接成一个完整装入模块

      02. 装入时动态链接

         - 运行前边装入边链接

      03. 运行时动态链接

         - 运行时需要目标模块才装入并链接

02. 操作系统负责内存的分配与回收

   1. 连续分配管理方式：分配的内存是连续的

      01. 单一连续分配

         - 优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定需要采取内存保护
         - 缺点：只能用于单用户、单任务操作系统，有内部碎片，储存器利用率低

      02. 固定分区分配：将用户区划分成若干个固定大小的分区，每个分区装入一道作业

         - 优点：实现简单，无外部碎片
         - 缺点产生内部碎片，内存利用率低，用户程序大，所有分区不满足，必须采用覆盖技术解决但会降低性能

         1. 分区大小相等

            - 缺乏灵活性，但是很适合用于一台计算机控制多个相同对象

         2. 分区大小不等

            - 增加灵活性，可以满足不同大小的进程需求

         3. 分区说明表：实现各个分区的分配与回收

      03. 动态分区分配：不会预先划分内存，而是动态的建立分区

         1. 空闲分区表或空闲分区链

         2. 动态分区分配算法

            01. 首次适应算法：按地址顺序链接，找到第一个能满足大小的空闲分区，

               - 在低地址部分出现外部碎片产生过多的查找开销
               - 不需要重排链表
               - 可能会在高地址部分产生大内存块，隐含了最佳适应算法

            02. 最佳适应算法：按容量递增的顺序链接，优先使用更小的空闲区

               - 算法开销大

               - 产生很多外部碎片
               - 需要对整个链表重排

            03. 最坏适应算法：按容量递减的顺序链接，优先使用更大的空闲区

               - 算法开销大

               - 不会产生过多的外部碎片
               - 需要对整个链表重排

            04. 邻近适应算法：按地址顺序链接成循环链，从上次查找的位置开始查找

               - 降低查找次数
               - 不需要重排链表
               - 高地址大分区更有可能被划分成小部分，产生外部碎片

         3. 动态分配

            01. 内部碎片：分配给某进程的内存区域中有些部分没有利用上
            02. 外部碎片：某些空闲分区太小而难以利用

               - 可以采用紧凑技术解决外部碎片，但是会产生很高时间代价
               - 运用中级交换，磁盘和内存交换以及动态重定位技术

   2. 非连续分配管理方式：分配的内存是离散的

      01. 基本分页存储管理：将内存分配为一个个大小相等的分区，将用户进程的空间分配与页框大小相等的页面

         1. 页表：为了知道进程的每个页面在内存中存放的位置，操作系统为每个进程建立一张页表

            - 进程的每一页对应一个页表项，每个页表项有页号对应页面和块号对应页框组成
            - 页表项会按顺序存放在内存中，在按字节编址 
            - 每个页表项的长度是相同的，页号是隐藏的

         2. 基本地址变换机构

            01. 页表寄存器：存放页面中的起始地址和页面长度

               1. 原理

                  - 进程未执行时页面中的起始地址和页面长度放在PCB中，进程被调度时，放在PTR中

               2. 变换过程

                  - 由PCB中的程序计数器指向下一条指令的逻辑地址，计算分页号和页内偏移量，在PTR中判断页面长度是否超过页面号，根据页面号、页表项长度相同、按字节编制得出页表项的地址，找到物理地址块号，根据物理地址和偏移量找到内存中数据

               3. 基本特点

                  01. 页式管理的地址是一维的
                  02. 页式管理系统中只要给出逻辑地址，就可以知道物理地址
                  03. 有两个访问内存，第一次在内存中找页表，第二次访问实际物理地址
            02.   具有快表的地址变换机构

               1. 局部性原理

                  01. 时间局部性：如果执行了程序中的某条指令或数据，不久后这条指令很可能再次被访问
                  02. 空间局部性：一旦程序访问了某个存储单元，在不久后，附近的存储单元也可能被访问
                  03. 根据局部性原理，可能会多次多某同意页表项访问

               2. 联想寄存器TLB

                  01. 用来存放当前访问的若干页表项，以加速地址变换的过程，存放在更快的寄存器中

               3. 变换过程

                  01. 在查询PTR之前查询TLB，若命中直接找到物理地址，未命中去物理地址中找页表
                  02. 并把未在TL中的页表项放入TLB，由于局部性原理导致速度变快
                  03. 若命中则只需一次访问内存的操作，未命中则两次访存
      02. 基本分段存储管理

         1. 单级页表的问题

            01. 连续存储可能导致太多连续占用
            01. 没必要让整个页表常驻内存

         2. 两级页表的原理

            01. 可以将连续的长页表分割成为不同的小页表
            02. 使用一个二级页表老维护这些小页表

         3. 如何实现地址变化

            01. 类别IP段，用不同的段来控制每一级页表

         4. 两级页表问题的几个细节

            01. 多级页表中，每级页表大小不能超过一个页面
            02. 多级页表的访存次数

      03. 分段
        01. 按照程序自身的逻辑将程序分段
        02. 每个段在内存中连续储存，各段之间可以不相邻
        03. 用户编程更加方便，程序的可读性更高
        04. 逻辑地址结构由段号和段内地址组成

           1. 段号的位数决定了每个进程最多可以分配几个段
           2. 段内地址决定每个段的最大长度

      04. 段表

           1. 段表由段长和段基址组成
           2. 各段表项长度相同
           3. 段号可以是隐含的

      05. 寻址过程

           1. 段表寄存器，当一个进程上处理机时，段表地址和段表长度将会被放在段表寄存器中
           2. 由段号和存放在段表寄存器中的段表长度判断是否越界
           3.  由段号和统一的段表项长度查找段表的段表项所在地址
           4.  通过段表中段长对段内地址检查，判断是否越界
           5.  通过基址和段内地址找到物理地址

      06. 分段分页对比

           1.  页是信息的物理单位，完全是系统行为，对用户不可见
           2.  段时信息逻辑单位，对用户可见。
           3.  页时固定的，段是不固定的。
           4.  分段更容易信息的共享和保护

      07. 段页式管理方式

           1. 分段、分页的优缺点
             1. 分页管理不会产生物理碎片，不方便按逻辑模块实现信息的共享和保护
             2. 产生外部碎片，方便信息共享和保护

      08. 段页式管理的逻辑物理结构

         1. 由段号、页号、页内偏移量
         2. 段号位数决定一个进程分多少段
         3. 页号位决定每个段最大有多少页
         4. 页内偏移量决定页面大小
         5. 段号和段内偏移对用户编程时可见的，其他部分时不可见的
         6. 段页式管理地址结构二维的

      09. 物理地址的转换

         1. 根据逻辑地址中的段号页号业内偏移量在段表寄存器判断查找段表
         2.  根据段表和段号查找页表地址
         3.  根据页号和页表查找物理地址
         4.  访问物理地址

      10. 虚拟存储技术
          01.  传统存储管理方式的特征特点
            01. 作业很大时，不能全部装入内存
            02. 大量作业要求运行时，内存容量不满足，多道程序并发度下降
            03. 一个作业一旦被装入内存，就会一直驻留在内存中
          02.  局部性原理
            01. 高速缓存技术

               1. 把近期频繁访问的数据放入更高速的储存器中

          03.  虚拟内存的定义和特征

               1. 把用的多的放入内存，用的少的从内存放外存
               2. 多次性，无需一次全部装入
               3. 对换性， 无需常驻内存
               4. 虚拟性，用户看到的内存容量大于实际内存容量

          04.  如何实现虚拟内存技术：请求技术，和置换技术
                01. 请求分页储存
                02. 请求分段储存
                03.  请求段页式储存
      11. 请求分页管理
          01.  请求页表结构
                01. 增加了状态位，标记是否已经被调入内存
                02. 增加了访问字段，判断最近被访问过几次，或最近一次的访问时间
                03. 修改位，判断是否修改过，没修改过直接删除不用调用会外存
                04. 外存地址，页面在外存中的存放位置
          02.  缺页中断机构
                01. 当访问页面不存在时，产生缺页中断，缺页进程内中断，进入阻塞队列，调页完成后将其唤醒
                02. 有空闲块直接调入，无空闲块，由页面置换算法选择一个页面调回外存或直接覆盖
          03.  地址变换机构
                01. 请求调页，判断是否在内存中
                02. 页面置换，判断时候需要进行置换
                03. 页表项的修改

      12. 页面置换算法：追求更少的缺页率
          01.  最佳置换算法（OPT）
                01.  淘汰的页面将是以后永不使用，或者在最长时间内不在被访问的页面
                01.  最理想的算法但是无法实现
          02.  先进先出置换算法（FIFO）
                01. 每次选择淘汰的页面是最早进入内存的页面
                02. Belady异常--为进程分配的物理块数增大时，缺页次数不增反减
                03. 算法性能差
          03.  最近最久未使用置换算法（LRU）
                01. 选择淘汰最近最久未使用的页面
                02. 需要专门硬件支持，算法性能号但是实现开销大
          04.  时钟置换算法（CLOCK/NRU）
                01. 把所有页面链接储存
                02. 每次对页面访问位为0，即最近未被访问的页面淘汰。
                03. 扫描过的页面访问位置为0
                04. 最多需要两轮扫描，即第一次扫描时访问位全为1，扫描后全为0，后淘汰一个
          05.  改进型时钟置换算法
                01.  优先淘汰访问位为0，修改位0，不修改标志位
                02.  第二轮访问位为0，修改位1，扫描过的页面访问位置0
                03.  若第二轮扫描失败，则重新扫面但是不修改标志位，查找第一个访问位为0，修改位0
                04.  第三轮扫描失败，重新扫描查找访问位0，修改位1进行替换
                05.  最多扫描4轮，标志位（1，1）
                06.  第一级最近没访问没修改；第二级最近没访问修改过；第三级最近访问过没修改；第四级最近访问过修改过
      13. 页面分配策略
          01.  驻留集：请求分页存储管理中给进程分配的物理块的集合；在采用了虚拟存储技术的系统中，驻留集大小一般小于进程总大小
                01. 固定分配：驻留集大小不变
                02. 可变分配：驻留集大小可变
                03. 局部置换：只能选择自己的物理块进行置换
                04. 全局置换：全局可以替换
                05. 不存在固定分配全局置换
          02.  策略
            01. 固定分配局部置换
                01. 若发生缺页，从本进程选一个调出再从外存调入
            02. 可变分配全局置换
                01. 被置换的进程物理块可能会减小，只要缺页就分配物理块，缺页发生概率会提高
            03. 可变分配局部置换
                01. 缺页时从自己物理块选择置换，若某进程缺页率太大，则动态分配一定物理块给该进程
          03.  调入页面的时机
                01. 预调页策略：基于空间局部性原理一次调入多个页面，程序首次调入时由程序员指出
                02.  请求调页策略：每次调入一个页面，发生缺页时
          04.  从何处调页
                01.  内存于外存对换区对换
                02.  若对换区大小不够，则凡是不会被修改的数据都从文件区调入，若没修改则直接调回文件区，修改过则调回交换区
                03.  第一次从文件区调出，若被使用过的需要换出则写回对换区（UNIX）
                04. 抖动（颠簸现象）：换出的页面马上又要换入内存
                05.  即分配给进程的物理块不够
          05.  工作集：进程再某段时间间隔里，进程实际访问页面的集合
                01. 根据工作集的大小确定驻留集的大小
                02. 驻留集的大小不能小于工作集的大小，否则将发生抖动现象

03. 操作系统的虚拟性：内存空间的扩充

   1. 覆盖技术：解决程序大小超过物理内存总和的技术

      01. 固定区和覆盖区

         - 固定区的内存运行中不会调入调出，覆盖区的可能会调入调出

         - 必须由程序员声明覆盖结构，操作系统完成自动覆盖，对用户不透明。
         - 用于早起的操作系统

   2. 交换技术：内存空间紧张时，进程在内存和磁盘间动态调度

      - 进程PCB存放内存
      - 进程数据一般存放在词牌对换区

   3. 交换技术与覆盖技术的区别

      01. 覆盖是在同一个程序或进程中的
      02. 交换实在不同进程或作业之间的

04.  地址转换

   4. 三种装入方式

      01. 绝对装入

         - 编译时产生绝对地址
         - 单道程序阶段，此时没有操作系统，有程序员指定

      02. 可重定位装入

         - 装入时将逻辑地址转换为物理地址
         - 用于早期的多道批处理操作系统

      03. 动态运行时装入

         - 运行时将逻辑地址转换为物理地址
         - 需要设置重定位寄存器
         - 现代操作系统

05.  内存存储保护：保证个进程在自己的内存空间内运行，不会越界访问

   5. CPU设置上下限寄存器
   6. 采用重定位寄存器和界地址寄存器

      01. 重定位寄存器存放进程的起始物理地址
      02. 界地址寄存器存放进程的最大逻辑地址
